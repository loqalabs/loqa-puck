
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/loqalabs/loqa-puck-go/cmd/main.go (16.4%)</option>
				
				<option value="file1">github.com/loqalabs/loqa-puck-go/internal/audio/audio.go (78.9%)</option>
				
				<option value="file2">github.com/loqalabs/loqa-puck-go/internal/audio/mock_backend.go (83.3%)</option>
				
				<option value="file3">github.com/loqalabs/loqa-puck-go/internal/audio/portaudio_backend.go (20.4%)</option>
				
				<option value="file4">github.com/loqalabs/loqa-puck-go/internal/nats/audio_subscriber.go (50.0%)</option>
				
				<option value="file5">github.com/loqalabs/loqa-puck-go/internal/transport/binary_frame.go (86.4%)</option>
				
				<option value="file6">github.com/loqalabs/loqa-puck-go/internal/transport/http_client.go (86.4%)</option>
				
				<option value="file7">github.com/loqalabs/loqa-puck-go/internal/transport/puck_client.go (89.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/loqalabs/loqa-puck-go/internal/audio"
        "github.com/loqalabs/loqa-puck-go/internal/nats"
        "github.com/loqalabs/loqa-puck-go/internal/transport"
)

// bytesToFloat32Array converts audio bytes (WAV format or raw 16-bit PCM) back to float32 samples
func bytesToFloat32Array(data []byte) []float32 <span class="cov8" title="1">{
        // Skip WAV header if present (check for "RIFF" signature)
        pcmData := data
        if len(data) &gt;= 44 &amp;&amp; string(data[0:4]) == "RIFF" &amp;&amp; string(data[8:12]) == "WAVE" </span><span class="cov8" title="1">{
                // WAV file detected, skip 44-byte header
                pcmData = data[44:]
        }</span>

        <span class="cov8" title="1">if len(pcmData)%2 != 0 </span><span class="cov8" title="1">{
                // Ensure even number of bytes for 16-bit samples
                pcmData = pcmData[:len(pcmData)-1]
        }</span>

        <span class="cov8" title="1">samples := make([]float32, len(pcmData)/2)
        for i := 0; i &lt; len(samples); i++ </span><span class="cov8" title="1">{
                // Convert from 16-bit PCM to float32 (little-endian)
                low := int16(pcmData[i*2])
                high := int16(pcmData[i*2+1])
                val := low | (high &lt;&lt; 8)
                samples[i] = float32(val) / 32767.0
        }</span>
        <span class="cov8" title="1">return samples</span>
}

func main() <span class="cov0" title="0">{
        // Command line flags
        hubAddr := flag.String("hub", "http://localhost:3000", "Hub HTTP address")
        puckID := flag.String("id", "loqa-puck-001", "Puck identifier")
        natsURL := flag.String("nats", "nats://localhost:4222", "NATS server URL")
        flag.Parse()

        log.Printf("üöÄ Starting Loqa Puck - Go Reference Implementation")
        log.Printf("üìã Puck ID: %s", *puckID)
        log.Printf("üéØ Hub Address: %s", *hubAddr)
        log.Printf("üì® NATS URL: %s", *natsURL)

        // Initialize audio system
        backend := audio.NewPortAudioBackend()
        puckAudio, err := audio.NewPuckAudio(backend)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to initialize audio: %v", err)
        }</span>
        <span class="cov0" title="0">defer puckAudio.Shutdown()

        // Initialize NATS audio subscriber
        audioSubscriber, err := nats.NewAudioSubscriber(*natsURL, *puckID, 10)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to initialize NATS audio subscriber: %v", err)
        }</span>
        <span class="cov0" title="0">defer audioSubscriber.Close()

        // Start listening for audio messages
        if err := audioSubscriber.Start(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to start NATS audio subscriber: %v", err)
        }</span>

        // Initialize HTTP streaming client
        <span class="cov0" title="0">client := transport.NewPuckClient(*hubAddr, *puckID)

        // Connect to hub with retry
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                if err := client.Connect(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è  Connection attempt %d failed: %v", i+1, err)
                        time.Sleep(2 * time.Second)
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }
        <span class="cov0" title="0">defer client.Disconnect()

        // Create channel for audio upload (fire-and-forget)
        audioChan := make(chan audio.AudioChunk, 10)

        // Start audio streaming to hub (upload only)
        if err := client.StreamAudio(audioChan, nil); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to start audio streaming: %v", err)
        }</span>

        // Start audio recording
        <span class="cov0" title="0">if err := puckAudio.StartRecording(audioChan); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("‚ùå Failed to start recording: %v", err)
        }</span>

        // Handle streaming audio from NATS
        <span class="cov0" title="0">streamManager := audioSubscriber.GetStreamManager()
        go func() </span><span class="cov0" title="0">{
                for audioChunk := range streamManager.GetPlaybackChannel() </span><span class="cov0" title="0">{
                        log.Printf("üîä Playing complete audio file (%d bytes)", len(audioChunk))

                        // Convert audio bytes to float32 samples for playback
                        audioData := bytesToFloat32Array(audioChunk)
                        if err := puckAudio.PlayAudio(audioData); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ùå Failed to play audio chunk: %v", err)
                        }</span>
                }
        }()

        // Display status
        <span class="cov0" title="0">fmt.Println()
        fmt.Println("üé§ Loqa Puck - Go Reference Implementation Active!")
        fmt.Println("===============================================")
        fmt.Println()
        fmt.Println("üéôÔ∏è  Microphone: Listening for wake word")
        fmt.Println("üéØ Wake Word: \"Hey Loqa\" (enabled)")
        fmt.Println("üîä Speakers: Ready for TTS playback via NATS")
        fmt.Println("üì° Audio Upload: HTTP/1.1 streaming with binary frames")
        fmt.Println("üì® Audio Download: TTS audio via NATS")
        fmt.Println("üîß ESP32 Ready: 4KB frame limits, optimized protocol")
        fmt.Println()
        fmt.Println("üí° Say \"Hey Loqa\" followed by your command!")
        fmt.Println("‚ö° Audio responses will stream immediately when ready")
        fmt.Println("‚èπÔ∏è  Press Ctrl+C to stop")
        fmt.Println()

        // Handle graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        &lt;-sigChan
        log.Println("\nüõë Shutting down puck service...")

        // Stop recording
        puckAudio.StopRecording()

        // Close channels
        close(audioChan)

        log.Println("üëã Puck service stopped")</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package audio

import (
        "fmt"
        "log"
        "math"
        "sync"
        "time"
)

// PuckAudio handles audio capture and playback for the puck device
type PuckAudio struct {
        sampleRate      float64
        framesPerBuffer int
        channels        int
        backend         AudioBackend
        inputStream     StreamInterface
        outputStream    StreamInterface
        isRecording     bool
        isPlaying       bool
        playbackMutex   sync.RWMutex

        // Audio queue for sequential playback
        audioQueue   chan []float32
        stopPlayback chan bool

        // VAD settings
        energyThreshold float64
        preBufferSize   int

        // Wake word detection
        wakeWordEnabled   bool
        wakeWordThreshold float64
        wakeWordPattern   []float64
}

// NewRelayAudio creates a new puck audio interface with PortAudio backend
// DEPRECATED: Use NewPuckAudio instead.
func NewRelayAudio() (*PuckAudio, error) <span class="cov8" title="1">{
        return NewPuckAudio(NewPortAudioBackend())
}</span>

// NewPuckAudio creates a new puck audio interface
func NewPuckAudio(backend AudioBackend) (*PuckAudio, error) <span class="cov8" title="1">{
        // Initialize the audio backend
        if err := backend.Initialize(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to initialize audio backend: %w", err)
        }</span>

        <span class="cov8" title="1">ra := &amp;PuckAudio{
                sampleRate:        22050.0, // 22.05kHz to match TTS output
                framesPerBuffer:   1024,
                channels:          1, // Mono
                backend:           backend,
                energyThreshold:   0.01,
                preBufferSize:     10, // ~200ms pre-buffer
                wakeWordEnabled:   true,
                wakeWordThreshold: 0.7,
                wakeWordPattern:   generateWakeWordPattern(), // Simple "hey loqa" pattern
                audioQueue:        make(chan []float32, 100), // Buffer up to 100 audio chunks
                stopPlayback:      make(chan bool, 1),
        }

        // Start audio playback worker
        go ra.audioPlaybackWorker()

        return ra, nil</span>
}

// AudioChunk represents a chunk of audio data
type AudioChunk struct {
        Data          []float32
        SampleRate    int32
        Channels      int32
        Timestamp     int64
        IsWakeWord    bool
        IsEndOfSpeech bool
}

// StartRecording begins audio capture with voice activity detection
func (pa *PuckAudio) StartRecording(audioChan chan&lt;- AudioChunk) error <span class="cov8" title="1">{
        if pa.isRecording </span><span class="cov8" title="1">{
                return fmt.Errorf("already recording")
        }</span>

        // Create input buffer
        <span class="cov8" title="1">inputBuffer := make([]float32, pa.framesPerBuffer*pa.channels)

        // Pre-recording circular buffer
        preBuffer := make([][]float32, pa.preBufferSize)
        preBufferIndex := 0

        // Create input stream
        inputStream, err := pa.backend.CreateInputStream(
                pa.sampleRate,
                pa.channels,
                pa.framesPerBuffer,
        )
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create input stream: %w", err)
        }</span>

        <span class="cov8" title="1">pa.inputStream = inputStream
        pa.isRecording = true

        if err := pa.inputStream.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start input stream: %w", err)
        }</span>

        <span class="cov8" title="1">log.Println("üé§ Relay: Started audio recording")

        // Recording loop
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := pa.inputStream.Stop(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ö†Ô∏è Failed to stop input stream: %v", err)
                        }</span>
                        <span class="cov8" title="1">if err := pa.inputStream.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ö†Ô∏è Failed to close input stream: %v", err)
                        }</span>
                        <span class="cov8" title="1">pa.isRecording = false
                        log.Println("üé§ Relay: Stopped audio recording")</span>
                }()

                <span class="cov8" title="1">voiceDetected := false
                lastVoiceTime := time.Now()
                recordingStart := time.Time{}
                var audioBuffer []float32
                var wakeWordBuffer []float32
                wakeWordDetected := false

                for pa.isRecording </span><span class="cov8" title="1">{
                        if err := pa.inputStream.Read(inputBuffer); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ùå Error reading audio: %v", err)
                                return
                        }</span>

                        // Make a copy for pre-buffer
                        <span class="cov8" title="1">bufferCopy := make([]float32, len(inputBuffer))
                        copy(bufferCopy, inputBuffer)

                        hasVoice := pa.calculateEnergy(inputBuffer) &gt; pa.energyThreshold

                        // Wake word detection
                        if pa.wakeWordEnabled &amp;&amp; hasVoice </span><span class="cov8" title="1">{
                                wakeWordBuffer = append(wakeWordBuffer, inputBuffer...)

                                // Keep wake word buffer at manageable size (2 seconds)
                                maxWakeWordSamples := int(pa.sampleRate * 2.0)
                                if len(wakeWordBuffer) &gt; maxWakeWordSamples </span><span class="cov0" title="0">{
                                        excess := len(wakeWordBuffer) - maxWakeWordSamples
                                        wakeWordBuffer = wakeWordBuffer[excess:]
                                }</span>

                                // Check for wake word pattern
                                <span class="cov8" title="1">if !wakeWordDetected &amp;&amp; len(wakeWordBuffer) &gt; len(pa.wakeWordPattern)*100 </span><span class="cov8" title="1">{
                                        confidence := pa.detectWakeWord(wakeWordBuffer)
                                        if confidence &gt; pa.wakeWordThreshold </span><span class="cov8" title="1">{
                                                wakeWordDetected = true
                                                log.Printf("üéØ Relay: Wake word detected! (confidence: %.2f)", confidence)
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if hasVoice &amp;&amp; (wakeWordDetected || !pa.wakeWordEnabled) </span><span class="cov8" title="1">{
                                if !voiceDetected </span><span class="cov8" title="1">{
                                        // Voice detected after wake word - start recording
                                        voiceDetected = true
                                        recordingStart = time.Now()
                                        log.Println("üé§ Relay: Voice detected! Starting transmission...")

                                        // Include pre-buffered audio
                                        for i := 0; i &lt; pa.preBufferSize; i++ </span><span class="cov8" title="1">{
                                                idx := (preBufferIndex + i) % pa.preBufferSize
                                                if preBuffer[idx] != nil </span><span class="cov8" title="1">{
                                                        audioBuffer = append(audioBuffer, preBuffer[idx]...)
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">lastVoiceTime = time.Now()
                                audioBuffer = append(audioBuffer, inputBuffer...)</span>

                        } else<span class="cov8" title="1"> if voiceDetected </span><span class="cov0" title="0">{
                                // Check for end of speech
                                timeSinceLast := time.Since(lastVoiceTime)
                                if timeSinceLast &gt; 2*time.Second </span><span class="cov0" title="0">{
                                        // End of speech detected
                                        log.Printf("üé§ Relay: End of speech detected - sending %.1fs of audio\n",
                                                time.Since(recordingStart).Seconds())

                                        // Send the complete audio buffer
                                        channels := pa.channels
                                        if channels &lt; 0 || channels &gt; 255 </span><span class="cov0" title="0">{
                                                log.Printf("‚ö†Ô∏è Invalid channel count: %d, using 1", channels)
                                                channels = 1
                                        }</span>
                                        // #nosec G115 - channels is bounds-checked above
                                        <span class="cov0" title="0">channelsInt32 := int32(channels)
                                        // Send wake word audio first if wake word was detected
                                        if wakeWordDetected &amp;&amp; wakeWordBuffer != nil </span><span class="cov0" title="0">{
                                                wakeWordChunk := AudioChunk{
                                                        Data:          wakeWordBuffer,
                                                        SampleRate:    int32(pa.sampleRate),
                                                        Channels:      channelsInt32,
                                                        Timestamp:     time.Now().UnixNano(),
                                                        IsWakeWord:    true,
                                                        IsEndOfSpeech: false,
                                                }

                                                select </span>{
                                                case audioChan &lt;- wakeWordChunk:<span class="cov0" title="0"></span>
                                                        // Successfully sent wake word
                                                default:<span class="cov0" title="0">
                                                        log.Println("‚ö†Ô∏è  Audio channel full, dropping wake word chunk")</span>
                                                }
                                        }

                                        // Send speech audio chunk
                                        <span class="cov0" title="0">chunk := AudioChunk{
                                                Data:          audioBuffer,
                                                SampleRate:    int32(pa.sampleRate),
                                                Channels:      channelsInt32,
                                                Timestamp:     time.Now().UnixNano(),
                                                IsWakeWord:    false, // This is speech, not wake word
                                                IsEndOfSpeech: true,
                                        }

                                        select </span>{
                                        case audioChan &lt;- chunk:<span class="cov0" title="0"></span>
                                                // Successfully sent
                                        default:<span class="cov0" title="0">
                                                log.Println("‚ö†Ô∏è  Audio channel full, dropping chunk")</span>
                                        }

                                        // Reset for next utterance (fire-and-forget)
                                        <span class="cov0" title="0">voiceDetected = false
                                        wakeWordDetected = false
                                        audioBuffer = nil
                                        wakeWordBuffer = nil
                                        log.Println("‚úÖ Relay: Audio sent, ready for next command")</span>
                                } else<span class="cov0" title="0"> {
                                        // Still within silence timeout
                                        audioBuffer = append(audioBuffer, inputBuffer...)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // No voice - store in pre-buffer
                                preBuffer[preBufferIndex] = bufferCopy
                                preBufferIndex = (preBufferIndex + 1) % pa.preBufferSize
                        }</span>

                        // Prevent busy waiting
                        <span class="cov8" title="1">time.Sleep(10 * time.Millisecond)</span>
                }
        }()

        <span class="cov8" title="1">return nil</span>
}

// StopRecording stops audio capture
func (pa *PuckAudio) StopRecording() <span class="cov8" title="1">{
        pa.isRecording = false
}</span>

// audioPlaybackWorker processes audio chunks sequentially from the queue
func (pa *PuckAudio) audioPlaybackWorker() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case audioData := &lt;-pa.audioQueue:<span class="cov8" title="1">
                        if err := pa.playAudioChunk(audioData); err != nil </span><span class="cov8" title="1">{
                                log.Printf("‚ùå Failed to play audio chunk: %v", err)
                        }</span>
                case &lt;-pa.stopPlayback:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// playAudioChunk plays a complete audio file through speakers
func (pa *PuckAudio) playAudioChunk(audioData []float32) error <span class="cov8" title="1">{
        // Set playing flag
        pa.playbackMutex.Lock()
        pa.isPlaying = true
        pa.playbackMutex.Unlock()

        // Ensure flag is cleared when done
        defer func() </span><span class="cov8" title="1">{
                pa.playbackMutex.Lock()
                pa.isPlaying = false
                pa.playbackMutex.Unlock()
        }</span>()

        <span class="cov8" title="1">log.Printf("üîä Relay: Playing %d samples of audio\n", len(audioData))

        // Create output stream
        outputStream, err := pa.backend.CreateOutputStream(
                pa.sampleRate,
                pa.channels,
                pa.framesPerBuffer,
        )
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create output stream: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := outputStream.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to close output stream: %v", err)
                }</span>
        }()

        <span class="cov8" title="1">if err := outputStream.Start(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start output stream: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := outputStream.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to stop output stream: %v", err)
                }</span>
        }()

        // Play audio in properly sized chunks
        <span class="cov8" title="1">samplesPlayed := 0
        for samplesPlayed &lt; len(audioData) </span><span class="cov8" title="1">{
                // Copy samples to write buffer
                remainingSamples := len(audioData) - samplesPlayed
                samplesToCopy := min(pa.framesPerBuffer, remainingSamples)

                // Create a chunk to write
                chunk := make([]float32, samplesToCopy)
                copy(chunk, audioData[samplesPlayed:samplesPlayed+samplesToCopy])

                // Write to stream
                if err := outputStream.Write(chunk); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error writing audio: %v", err)
                }</span>

                <span class="cov8" title="1">samplesPlayed += samplesToCopy</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PlayAudio queues audio data for sequential playback
func (pa *PuckAudio) PlayAudio(audioData []float32) error <span class="cov8" title="1">{
        pa.playbackMutex.RLock()
        currentlyPlaying := pa.isPlaying
        pa.playbackMutex.RUnlock()

        if currentlyPlaying </span><span class="cov8" title="1">{
                return fmt.Errorf("audio is already playing")
        }</span>

        <span class="cov8" title="1">select </span>{
        case pa.audioQueue &lt;- audioData:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("audio queue is full")</span>
        }
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// calculateEnergy calculates the RMS energy of an audio buffer
func (pa *PuckAudio) calculateEnergy(buffer []float32) float64 <span class="cov8" title="1">{
        if len(buffer) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var sum float64
        for _, sample := range buffer </span><span class="cov8" title="1">{
                sum += float64(sample * sample)
        }</span>

        <span class="cov8" title="1">return math.Sqrt(sum / float64(len(buffer)))</span>
}

// Shutdown cleans up audio resources
func (pa *PuckAudio) Shutdown() <span class="cov8" title="1">{
        pa.StopRecording()

        // Stop audio playback worker
        select </span>{
        case pa.stopPlayback &lt;- true:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }

        // Close audio queue
        <span class="cov8" title="1">close(pa.audioQueue)

        if pa.outputStream != nil &amp;&amp; pa.isPlaying </span><span class="cov0" title="0">{
                if err := pa.outputStream.Stop(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to stop output stream during shutdown: %v", err)
                }</span>
                <span class="cov0" title="0">if err := pa.outputStream.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to close output stream during shutdown: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if err := pa.backend.Terminate(); err != nil </span><span class="cov0" title="0">{
                log.Printf("‚ö†Ô∏è Failed to terminate audio backend: %v", err)
        }</span>
        <span class="cov8" title="1">log.Println("üîå Relay: Audio system shutdown")</span>
}

// generateWakeWordPattern creates a simple frequency pattern for "hey loqa"
func generateWakeWordPattern() []float64 <span class="cov8" title="1">{
        // Simple frequency envelope pattern approximating "hey loqa"
        // This is a very basic pattern - in production you'd use proper ML models
        return []float64{
                0.1, 0.3, 0.8, 0.6, 0.2, // "hey" - rising then falling
                0.1, 0.1, 0.1, // pause
                0.2, 0.5, 0.4, 0.7, 0.3, // "lo" - moderate energy
                0.6, 0.8, 0.5, 0.2, // "qa" - peak then drop
        }
}</span>

// detectWakeWord performs basic pattern matching for wake word detection
func (pa *PuckAudio) detectWakeWord(audioBuffer []float32) float64 <span class="cov8" title="1">{
        if len(audioBuffer) == 0 || len(pa.wakeWordPattern) == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        // Calculate energy envelope of the audio
        <span class="cov8" title="1">chunkSize := len(audioBuffer) / len(pa.wakeWordPattern)
        if chunkSize &lt; 100 </span><span class="cov8" title="1">{ // Need minimum samples per chunk
                return 0.0
        }</span>

        <span class="cov8" title="1">var audioEnvelope []float64
        for i := 0; i &lt; len(pa.wakeWordPattern); i++ </span><span class="cov8" title="1">{
                start := i * chunkSize
                end := start + chunkSize
                if end &gt; len(audioBuffer) </span><span class="cov0" title="0">{
                        end = len(audioBuffer)
                }</span>

                <span class="cov8" title="1">chunk := audioBuffer[start:end]
                energy := pa.calculateEnergy(chunk)
                audioEnvelope = append(audioEnvelope, energy)</span>
        }

        // Normalize audio envelope
        <span class="cov8" title="1">maxEnergy := 0.0
        for _, energy := range audioEnvelope </span><span class="cov8" title="1">{
                if energy &gt; maxEnergy </span><span class="cov8" title="1">{
                        maxEnergy = energy
                }</span>
        }

        <span class="cov8" title="1">if maxEnergy == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>

        <span class="cov8" title="1">for i := range audioEnvelope </span><span class="cov8" title="1">{
                audioEnvelope[i] /= maxEnergy
        }</span>

        // Calculate correlation with wake word pattern
        <span class="cov8" title="1">correlation := 0.0
        for i := 0; i &lt; len(pa.wakeWordPattern) &amp;&amp; i &lt; len(audioEnvelope); i++ </span><span class="cov8" title="1">{
                correlation += pa.wakeWordPattern[i] * audioEnvelope[i]
        }</span>

        // Normalize correlation
        <span class="cov8" title="1">patternEnergy := 0.0
        for _, val := range pa.wakeWordPattern </span><span class="cov8" title="1">{
                patternEnergy += val * val
        }</span>

        <span class="cov8" title="1">if patternEnergy == 0 </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">confidence := correlation / math.Sqrt(patternEnergy)
        return math.Max(0.0, math.Min(1.0, confidence))</span>
}

// EnableWakeWord enables or disables wake word detection
func (pa *PuckAudio) EnableWakeWord(enabled bool) <span class="cov8" title="1">{
        pa.wakeWordEnabled = enabled
        if enabled </span><span class="cov8" title="1">{
                log.Println("üéØ Relay: Wake word detection enabled")
        }</span> else<span class="cov8" title="1"> {
                log.Println("üéØ Relay: Wake word detection disabled")
        }</span>
}

// SetWakeWordThreshold sets the confidence threshold for wake word detection
func (pa *PuckAudio) SetWakeWordThreshold(threshold float64) <span class="cov8" title="1">{
        pa.wakeWordThreshold = math.Max(0.0, math.Min(1.0, threshold))
        log.Printf("üéØ Relay: Wake word threshold set to %.2f", pa.wakeWordThreshold)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package audio

import (
        "fmt"
        "math"
        "sync"
        "time"
)

// MockAudioBackend implements AudioBackend for testing without hardware dependencies
type MockAudioBackend struct {
        mu                  sync.Mutex
        initialized         bool
        streams             map[string]*MockStream
        streamCounter       int
        initError           error
        terminateError      error
        createStreamError   error
        simulateRealTiming  bool
        recordedAudioData   [][]float32
        playbackAudioData   [][]float32
}

// NewMockAudioBackend creates a new mock audio backend
func NewMockAudioBackend() *MockAudioBackend <span class="cov8" title="1">{
        return &amp;MockAudioBackend{
                streams:           make(map[string]*MockStream),
                simulateRealTiming: true,
                recordedAudioData:  make([][]float32, 0),
                playbackAudioData:  make([][]float32, 0),
        }
}</span>

// SetInitError configures the backend to return an error on Initialize()
func (m *MockAudioBackend) SetInitError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.initError = err
}</span>

// SetCreateStreamError configures the backend to return an error on stream creation
func (m *MockAudioBackend) SetCreateStreamError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.createStreamError = err
}</span>

// SetSimulateRealTiming controls whether the mock simulates real audio timing
func (m *MockAudioBackend) SetSimulateRealTiming(simulate bool) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.simulateRealTiming = simulate
}</span>

// GetRecordedAudioData returns all audio data that was "recorded"
func (m *MockAudioBackend) GetRecordedAudioData() [][]float32 <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        result := make([][]float32, len(m.recordedAudioData))
        copy(result, m.recordedAudioData)
        return result
}</span>

// GetPlaybackAudioData returns all audio data that was "played back"
func (m *MockAudioBackend) GetPlaybackAudioData() [][]float32 <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        result := make([][]float32, len(m.playbackAudioData))
        copy(result, m.playbackAudioData)
        return result
}</span>

// Initialize initializes the mock audio subsystem
func (m *MockAudioBackend) Initialize() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.initError != nil </span><span class="cov8" title="1">{
                return m.initError
        }</span>

        <span class="cov8" title="1">m.initialized = true
        return nil</span>
}

// Terminate terminates the mock audio subsystem
func (m *MockAudioBackend) Terminate() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.terminateError != nil </span><span class="cov0" title="0">{
                return m.terminateError
        }</span>

        // Stop all streams first without holding locks
        <span class="cov8" title="1">var streams []StreamInterface
        for _, stream := range m.streams </span><span class="cov8" title="1">{
                streams = append(streams, stream)
        }</span>

        // Release the lock before calling Stop/Close to avoid deadlocks
        <span class="cov8" title="1">m.mu.Unlock()

        for _, stream := range streams </span><span class="cov8" title="1">{
                stream.Stop()
                stream.Close()
        }</span>

        // Re-acquire lock to update state
        <span class="cov8" title="1">m.mu.Lock()
        m.initialized = false
        return nil</span>
}

// CreateInputStream creates a mock input stream
func (m *MockAudioBackend) CreateInputStream(sampleRate float64, channels, bufferSize int) (StreamInterface, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if !m.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("mock audio backend not initialized")
        }</span>

        <span class="cov8" title="1">if m.createStreamError != nil </span><span class="cov8" title="1">{
                return nil, m.createStreamError
        }</span>

        <span class="cov8" title="1">streamID := fmt.Sprintf("input_%d", m.streamCounter)
        m.streamCounter++

        stream := &amp;MockStream{
                id:                 streamID,
                backend:            m,
                sampleRate:         sampleRate,
                channels:           channels,
                bufferSize:         bufferSize,
                isInput:            true,
                simulateRealTiming: m.simulateRealTiming,
                stopChannel:        make(chan bool, 1),
        }

        m.streams[streamID] = stream
        return stream, nil</span>
}

// CreateOutputStream creates a mock output stream
func (m *MockAudioBackend) CreateOutputStream(sampleRate float64, channels, bufferSize int) (StreamInterface, error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if !m.initialized </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("mock audio backend not initialized")
        }</span>

        <span class="cov8" title="1">if m.createStreamError != nil </span><span class="cov0" title="0">{
                return nil, m.createStreamError
        }</span>

        <span class="cov8" title="1">streamID := fmt.Sprintf("output_%d", m.streamCounter)
        m.streamCounter++

        stream := &amp;MockStream{
                id:                 streamID,
                backend:            m,
                sampleRate:         sampleRate,
                channels:           channels,
                bufferSize:         bufferSize,
                isInput:            false,
                simulateRealTiming: m.simulateRealTiming,
                stopChannel:        make(chan bool, 1),
        }

        m.streams[streamID] = stream
        return stream, nil</span>
}

// MockStream implements StreamInterface for testing
type MockStream struct {
        mu                 sync.Mutex
        id                 string
        backend            *MockAudioBackend
        sampleRate         float64
        channels           int
        bufferSize         int
        isInput            bool
        isOpen             bool
        isActive           bool
        simulateRealTiming bool
        callback           StreamCallback
        stopChannel        chan bool
        startError         error
        stopError          error
        closeError         error
        writeError         error
        readError          error
        audioDataGenerator func([]float32) // For generating mock audio input
}

// SetStartError configures the stream to return an error on Start()
func (m *MockStream) SetStartError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.startError = err
}</span>

// SetWriteError configures the stream to return an error on Write()
func (m *MockStream) SetWriteError(err error) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.writeError = err
}</span>

// SetAudioDataGenerator sets a function to generate mock audio input data
func (m *MockStream) SetAudioDataGenerator(generator func([]float32)) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.audioDataGenerator = generator
}</span>

// Start starts the mock stream
func (m *MockStream) Start() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.startError != nil </span><span class="cov8" title="1">{
                return m.startError
        }</span>

        <span class="cov8" title="1">if m.isActive </span><span class="cov0" title="0">{
                return fmt.Errorf("stream already active")
        }</span>

        <span class="cov8" title="1">m.isActive = true
        m.isOpen = true

        // Start background processing for input streams
        if m.isInput </span><span class="cov8" title="1">{
                go m.simulateAudioInput()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Stop stops the mock stream
func (m *MockStream) Stop() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.stopError != nil </span><span class="cov0" title="0">{
                return m.stopError
        }</span>

        <span class="cov8" title="1">if !m.isActive </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">m.isActive = false

        // Signal stop to background goroutine
        select </span>{
        case m.stopChannel &lt;- true:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Close closes the mock stream
func (m *MockStream) Close() error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.closeError != nil </span><span class="cov0" title="0">{
                return m.closeError
        }</span>

        <span class="cov8" title="1">if !m.isOpen </span><span class="cov8" title="1">{
                return nil // Already closed
        }</span>

        <span class="cov8" title="1">m.isOpen = false
        m.isActive = false

        // Signal stop to avoid deadlocks
        select </span>{
        case m.stopChannel &lt;- true:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1"></span>
        }

        // Remove from backend - use a separate goroutine to avoid deadlock
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                m.backend.mu.Lock()
                delete(m.backend.streams, m.id)
                m.backend.mu.Unlock()
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// Write writes audio data to the mock output stream
func (m *MockStream) Write(data []float32) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.writeError != nil </span><span class="cov8" title="1">{
                return m.writeError
        }</span>

        <span class="cov8" title="1">if !m.isOpen </span><span class="cov0" title="0">{
                return fmt.Errorf("stream not open")
        }</span>

        <span class="cov8" title="1">if m.isInput </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write to input stream")
        }</span>

        // Record the audio data
        <span class="cov8" title="1">dataCopy := make([]float32, len(data))
        copy(dataCopy, data)

        m.backend.mu.Lock()
        m.backend.playbackAudioData = append(m.backend.playbackAudioData, dataCopy)
        m.backend.mu.Unlock()

        // Simulate real timing if enabled
        if m.simulateRealTiming </span><span class="cov8" title="1">{
                duration := time.Duration(float64(len(data)) / m.sampleRate * float64(time.Second))
                time.Sleep(duration)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Read reads audio data from the mock input stream
func (m *MockStream) Read(data []float32) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if m.readError != nil </span><span class="cov0" title="0">{
                return m.readError
        }</span>

        <span class="cov8" title="1">if !m.isOpen </span><span class="cov0" title="0">{
                return fmt.Errorf("stream not open")
        }</span>

        <span class="cov8" title="1">if !m.isInput </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read from output stream")
        }</span>

        // Generate mock audio data
        <span class="cov8" title="1">if m.audioDataGenerator != nil </span><span class="cov0" title="0">{
                m.audioDataGenerator(data)
        }</span> else<span class="cov8" title="1"> {
                // Default: generate a simple sine wave
                for i := range data </span><span class="cov8" title="1">{
                        // 440 Hz sine wave
                        t := float64(i) / m.sampleRate
                        data[i] = float32(0.1 * math.Sin(2*math.Pi*440*t))
                }</span>
        }

        // Record the audio data
        <span class="cov8" title="1">dataCopy := make([]float32, len(data))
        copy(dataCopy, data)

        m.backend.mu.Lock()
        m.backend.recordedAudioData = append(m.backend.recordedAudioData, dataCopy)
        m.backend.mu.Unlock()

        // Simulate real timing if enabled
        if m.simulateRealTiming </span><span class="cov8" title="1">{
                duration := time.Duration(float64(len(data)) / m.sampleRate * float64(time.Second))
                time.Sleep(duration)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsActive returns true if the mock stream is active
func (m *MockStream) IsActive() bool <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.isActive
}</span>

// SetCallback sets the callback function
func (m *MockStream) SetCallback(callback StreamCallback) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.callback = callback
        return nil
}</span>

// simulateAudioInput runs in background to simulate continuous audio input
func (m *MockStream) simulateAudioInput() <span class="cov8" title="1">{
        buffer := make([]float32, m.bufferSize*m.channels)
        ticker := time.NewTicker(time.Duration(float64(m.bufferSize)/m.sampleRate*1000) * time.Millisecond)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-m.stopChannel:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        // Check if still active without holding lock for too long
                        m.mu.Lock()
                        isActive := m.isActive
                        m.mu.Unlock()

                        if !isActive </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Generate audio data
                        <span class="cov8" title="1">m.mu.Lock()
                        if m.audioDataGenerator != nil </span><span class="cov0" title="0">{
                                m.audioDataGenerator(buffer)
                        }</span> else<span class="cov8" title="1"> {
                                // Default: generate sine wave with some variation
                                for i := range buffer </span><span class="cov8" title="1">{
                                        t := float64(time.Now().UnixNano()) / 1e9
                                        buffer[i] = float32(0.1 * math.Sin(2*math.Pi*440*t))
                                }</span>
                        }
                        <span class="cov8" title="1">m.mu.Unlock()

                        // Record the data
                        dataCopy := make([]float32, len(buffer))
                        copy(dataCopy, buffer)

                        m.backend.mu.Lock()
                        m.backend.recordedAudioData = append(m.backend.recordedAudioData, dataCopy)
                        m.backend.mu.Unlock()</span>
                }
        }
}</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package audio

import (
        "fmt"

        "github.com/gordonklaus/portaudio"
)

// PortAudioBackend implements AudioBackend using the real PortAudio library
type PortAudioBackend struct {
        initialized bool
}

// NewPortAudioBackend creates a new PortAudio backend
func NewPortAudioBackend() *PortAudioBackend <span class="cov8" title="1">{
        return &amp;PortAudioBackend{}
}</span>

// Initialize initializes the PortAudio subsystem
func (p *PortAudioBackend) Initialize() error <span class="cov8" title="1">{
        if p.initialized </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := portaudio.Initialize(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to initialize PortAudio: %w", err)
        }</span>

        <span class="cov8" title="1">p.initialized = true
        return nil</span>
}

// Terminate terminates the PortAudio subsystem
func (p *PortAudioBackend) Terminate() error <span class="cov8" title="1">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">err := portaudio.Terminate()
        p.initialized = false
        return err</span>
}

// CreateInputStream creates an input stream for recording
func (p *PortAudioBackend) CreateInputStream(sampleRate float64, channels, bufferSize int) (StreamInterface, error) <span class="cov0" title="0">{
        if !p.initialized </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("PortAudio not initialized")
        }</span>

        // Create input buffer
        <span class="cov0" title="0">inputBuffer := make([]float32, bufferSize*channels)

        stream, err := portaudio.OpenDefaultStream(
                channels, // input channels
                0,        // output channels (none for input stream)
                sampleRate,
                bufferSize,
                inputBuffer,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open input stream: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PortAudioStream{
                stream:      stream,
                inputBuffer: inputBuffer,
                isInput:     true,
        }, nil</span>
}

// CreateOutputStream creates an output stream for playback
func (p *PortAudioBackend) CreateOutputStream(sampleRate float64, channels, bufferSize int) (StreamInterface, error) <span class="cov8" title="1">{
        if !p.initialized </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("PortAudio not initialized")
        }</span>

        // Create output buffer
        <span class="cov0" title="0">outputBuffer := make([]float32, bufferSize*channels)

        stream, err := portaudio.OpenDefaultStream(
                0,        // input channels (none for output stream)
                channels, // output channels
                sampleRate,
                bufferSize,
                outputBuffer,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open output stream: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;PortAudioStream{
                stream:       stream,
                outputBuffer: outputBuffer,
                isInput:      false,
        }, nil</span>
}

// PortAudioStream implements StreamInterface using PortAudio streams
type PortAudioStream struct {
        stream       *portaudio.Stream
        inputBuffer  []float32
        outputBuffer []float32
        isInput      bool
        callback     StreamCallback
}

// Start starts the audio stream
func (p *PortAudioStream) Start() error <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stream is nil")
        }</span>
        <span class="cov0" title="0">return p.stream.Start()</span>
}

// Stop stops the audio stream
func (p *PortAudioStream) Stop() error <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stream is nil")
        }</span>
        <span class="cov0" title="0">return p.stream.Stop()</span>
}

// Close closes the audio stream
func (p *PortAudioStream) Close() error <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stream is nil")
        }</span>
        <span class="cov0" title="0">return p.stream.Close()</span>
}

// Write writes audio data to the output stream
func (p *PortAudioStream) Write(data []float32) error <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stream is nil")
        }</span>
        <span class="cov0" title="0">if p.isInput </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot write to input stream")
        }</span>

        // Copy data to output buffer
        <span class="cov0" title="0">copy(p.outputBuffer, data)
        return p.stream.Write()</span>
}

// Read reads audio data from the input stream
func (p *PortAudioStream) Read(data []float32) error <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("stream is nil")
        }</span>
        <span class="cov0" title="0">if !p.isInput </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot read from output stream")
        }</span>

        <span class="cov0" title="0">if err := p.stream.Read(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Copy data from input buffer
        <span class="cov0" title="0">copy(data, p.inputBuffer)
        return nil</span>
}

// IsActive returns true if the stream is active
func (p *PortAudioStream) IsActive() bool <span class="cov0" title="0">{
        if p.stream == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        // PortAudio doesn't have IsActive method, we track state manually
        // In practice, a stream is active if it has been started and not stopped
        <span class="cov0" title="0">return true</span> // Simplified for now - could track state if needed
}

// SetCallback sets the callback function (not used in this implementation)
func (p *PortAudioStream) SetCallback(callback StreamCallback) error <span class="cov0" title="0">{
        p.callback = callback
        return nil
}</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package nats

import (
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/nats-io/nats.go"
)

// AudioStreamMessage represents complete audio file from hub to puck
type AudioStreamMessage struct {
        StreamID    string `json:"stream_id"`    // Unique identifier for this audio stream
        AudioData   []byte `json:"audio_data"`   // Complete audio file data
        AudioFormat string `json:"audio_format"` // Format (e.g., "wav", "mp3")
        SampleRate  int    `json:"sample_rate"`  // Sample rate for audio data
        MessageType string `json:"message_type"` // "response", "timer", "reminder", "system"
        Priority    int    `json:"priority"`     // 1=highest, 5=lowest
}

// PuckNATSConnection interface for dependency injection
type PuckNATSConnection interface {
        Subscribe(subject string, cb nats.MsgHandler) (*nats.Subscription, error)
        Close()
}

// PuckNATSConnectionAdapter adapts *nats.Conn to PuckNATSConnection interface
type PuckNATSConnectionAdapter struct {
        conn *nats.Conn
}

func NewPuckNATSConnectionAdapter(conn *nats.Conn) *PuckNATSConnectionAdapter <span class="cov0" title="0">{
        return &amp;PuckNATSConnectionAdapter{conn: conn}
}</span>

func (r *PuckNATSConnectionAdapter) Subscribe(subject string, cb nats.MsgHandler) (*nats.Subscription, error) <span class="cov0" title="0">{
        return r.conn.Subscribe(subject, cb)
}</span>

func (r *PuckNATSConnectionAdapter) Close() <span class="cov0" title="0">{
        r.conn.Close()
}</span>

// AudioStreamManager manages audio playback queue (simplified for complete file delivery)
type AudioStreamManager struct {
        playbackCh chan []byte // Channel for immediate audio playback
        capacity   int
}

// NewAudioStreamManager creates a new audio stream manager
func NewAudioStreamManager(capacity int) *AudioStreamManager <span class="cov8" title="1">{
        return &amp;AudioStreamManager{
                playbackCh: make(chan []byte, capacity),
                capacity:   capacity,
        }
}</span>

// GetPlaybackChannel returns the channel for audio playback
func (asm *AudioStreamManager) GetPlaybackChannel() &lt;-chan []byte <span class="cov8" title="1">{
        return asm.playbackCh
}</span>

// AudioSubscriber handles NATS subscriptions for audio streams
type AudioSubscriber struct {
        natsConn      PuckNATSConnection
        puckID       string
        streamManager *AudioStreamManager
}

// NewAudioSubscriber creates a new NATS audio subscriber
func NewAudioSubscriber(natsURL, puckID string, streamCapacity int) (*AudioSubscriber, error) <span class="cov0" title="0">{
        // Connect to NATS with retry
        var nc *nats.Conn
        var err error

        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                nc, err = nats.Connect(natsURL)
                if err == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">log.Printf("‚ö†Ô∏è  Failed to connect to NATS (attempt %d/5): %v", i+1, err)
                time.Sleep(2 * time.Second)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to NATS after 5 attempts: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("‚úÖ Connected to NATS at %s", natsURL)

        return &amp;AudioSubscriber{
                natsConn:      NewPuckNATSConnectionAdapter(nc),
                puckID:       puckID,
                streamManager: NewAudioStreamManager(streamCapacity),
        }, nil</span>
}

// NewAudioSubscriberWithConnection creates a new NATS audio subscriber with an existing connection (for testing)
func NewAudioSubscriberWithConnection(natsConn PuckNATSConnection, puckID string, streamCapacity int) *AudioSubscriber <span class="cov8" title="1">{
        return &amp;AudioSubscriber{
                natsConn:      natsConn,
                puckID:       puckID,
                streamManager: NewAudioStreamManager(streamCapacity),
        }
}</span>

// Start begins listening for audio messages
func (as *AudioSubscriber) Start() error <span class="cov8" title="1">{
        // Subscribe to relay-specific audio topic
        puckTopic := fmt.Sprintf("audio.%s", as.puckID)
        _, err := as.natsConn.Subscribe(puckTopic, as.handleAudioMessage)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to subscribe to %s: %w", puckTopic, err)
        }</span>

        // Subscribe to broadcast audio topic
        <span class="cov8" title="1">broadcastTopic := "audio.broadcast"
        _, err = as.natsConn.Subscribe(broadcastTopic, as.handleAudioMessage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to subscribe to %s: %w", broadcastTopic, err)
        }</span>

        <span class="cov8" title="1">log.Printf("üéß Subscribed to audio topics: %s, %s", puckTopic, broadcastTopic)
        return nil</span>
}

// handleAudioMessage processes incoming complete audio files from NATS
func (as *AudioSubscriber) handleAudioMessage(msg *nats.Msg) <span class="cov8" title="1">{
        var streamMsg AudioStreamMessage
        if err := json.Unmarshal(msg.Data, &amp;streamMsg); err != nil </span><span class="cov8" title="1">{
                log.Printf("‚ùå Failed to unmarshal audio stream message: %v", err)
                return
        }</span>

        <span class="cov8" title="1">log.Printf("üì• Received complete audio file: stream=%s, size=%d bytes, type=%s, format=%s",
                streamMsg.StreamID, len(streamMsg.AudioData), streamMsg.MessageType, streamMsg.AudioFormat)

        // Send complete audio file directly to playback channel
        select </span>{
        case as.streamManager.playbackCh &lt;- streamMsg.AudioData:<span class="cov8" title="1">
                log.Printf("üîä Queued complete audio file for playback: %s", streamMsg.StreamID)</span>
        default:<span class="cov8" title="1">
                log.Printf("‚ö†Ô∏è  Playback channel full, dropping audio file: %s", streamMsg.StreamID)</span>
        }
}

// GetStreamManager returns the audio stream manager for processing
func (as *AudioSubscriber) GetStreamManager() *AudioStreamManager <span class="cov0" title="0">{
        return as.streamManager
}</span>

// Close closes the NATS connection
func (as *AudioSubscriber) Close() <span class="cov0" title="0">{
        if as.natsConn != nil </span><span class="cov0" title="0">{
                as.natsConn.Close()
                log.Println("üîå NATS connection closed")
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package transport

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
)

// Binary Frame Protocol for HTTP/1.1 Chunked Transfer
// Designed for ESP32 compatibility with minimal overhead

// FrameType represents the type of frame being transmitted
type FrameType uint8

const (
        // Audio frame types
        FrameTypeAudioData FrameType = 0x01
        FrameTypeAudioEnd  FrameType = 0x02
        FrameTypeWakeWord  FrameType = 0x03

        // Control frame types
        FrameTypeHeartbeat   FrameType = 0x10
        FrameTypeHandshake   FrameType = 0x11
        FrameTypeError       FrameType = 0x12
        FrameTypeArbitration FrameType = 0x13

        // Response frame types
        FrameTypeResponse FrameType = 0x20
        FrameTypeStatus   FrameType = 0x21
)

// Frame represents a binary frame in the protocol
type Frame struct {
        Type      FrameType
        SessionID uint32
        Sequence  uint32
        Timestamp uint64
        Data      []byte
}

// FrameHeader represents the fixed-size frame header (20 bytes)
type FrameHeader struct {
        Magic     uint32    // 0x4C4F5141 ("LOQA")
        Type      FrameType // Frame type (1 byte)
        Reserved  uint8     // Reserved for future use (1 byte)
        Length    uint16    // Data payload length (2 bytes)
        SessionID uint32    // Session identifier (4 bytes)
        Sequence  uint32    // Sequence number (4 bytes)
        Timestamp uint64    // Unix timestamp microseconds (8 bytes)
}

const (
        // Magic number for frame validation
        FrameMagic = 0x4C4F5141 // "LOQA" in big-endian

        // Frame size constraints for ESP32 compatibility
        MaxFrameSize = 1536 // 1.5KB max frame size for ESP32 SRAM constraints
        HeaderSize   = 24   // Fixed header size
        MaxDataSize  = MaxFrameSize - HeaderSize
)

// Serialize converts a frame to binary format
func (f *Frame) Serialize() ([]byte, error) <span class="cov8" title="1">{
        if len(f.Data) &gt; MaxDataSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("frame data too large: %d bytes (max %d)", len(f.Data), MaxDataSize)
        }</span>

        // Check data length to prevent overflow
        <span class="cov8" title="1">dataLen := len(f.Data)
        if dataLen &gt; 65535 </span><span class="cov0" title="0">{ // Max uint16
                dataLen = 65535
        }</span>

        <span class="cov8" title="1">header := FrameHeader{
                Magic:     FrameMagic,
                Type:      f.Type,
                Reserved:  0,
                Length:    uint16(dataLen), //nolint:gosec // G115: Safe conversion after bounds check above
                SessionID: f.SessionID,
                Sequence:  f.Sequence,
                Timestamp: f.Timestamp,
        }

        buf := new(bytes.Buffer)

        // Write header in big-endian format
        if err := binary.Write(buf, binary.BigEndian, header); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write frame header: %w", err)
        }</span>

        // Write data payload
        <span class="cov8" title="1">if len(f.Data) &gt; 0 </span><span class="cov8" title="1">{
                if _, err := buf.Write(f.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write frame data: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// Deserialize converts binary data to a frame
func DeserializeFrame(data []byte) (*Frame, error) <span class="cov8" title="1">{
        if len(data) &lt; HeaderSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("frame too small: %d bytes (min %d)", len(data), HeaderSize)
        }</span>

        <span class="cov8" title="1">buf := bytes.NewReader(data)
        var header FrameHeader

        if err := binary.Read(buf, binary.BigEndian, &amp;header); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read frame header: %w", err)
        }</span>

        // Validate magic number
        <span class="cov8" title="1">if header.Magic != FrameMagic </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid frame magic: 0x%08X (expected 0x%08X)", header.Magic, FrameMagic)
        }</span>

        // Validate frame size
        <span class="cov8" title="1">expectedSize := HeaderSize + int(header.Length)
        if len(data) != expectedSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("frame size mismatch: got %d bytes, expected %d", len(data), expectedSize)
        }</span>

        <span class="cov8" title="1">frame := &amp;Frame{
                Type:      header.Type,
                SessionID: header.SessionID,
                Sequence:  header.Sequence,
                Timestamp: header.Timestamp,
        }

        // Read data payload if present
        if header.Length &gt; 0 </span><span class="cov8" title="1">{
                frame.Data = make([]byte, header.Length)
                if _, err := io.ReadFull(buf, frame.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to read frame data: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return frame, nil</span>
}

// parseFrameHeader parses just the header portion of frame data
// This is used when reading frames incrementally (header first, then data)
func parseFrameHeader(headerData []byte) (*FrameHeader, error) <span class="cov8" title="1">{
        if len(headerData) != HeaderSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid header size: %d bytes (expected %d)", len(headerData), HeaderSize)
        }</span>

        <span class="cov8" title="1">buf := bytes.NewReader(headerData)
        var header FrameHeader

        if err := binary.Read(buf, binary.BigEndian, &amp;header); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read frame header: %w", err)
        }</span>

        // Validate magic number
        <span class="cov8" title="1">if header.Magic != FrameMagic </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid frame magic: 0x%08X (expected 0x%08X)", header.Magic, FrameMagic)
        }</span>

        // Validate data length doesn't exceed maximum
        <span class="cov8" title="1">if header.Length &gt; MaxDataSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("frame data too large: %d bytes (max %d)", header.Length, MaxDataSize)
        }</span>

        <span class="cov8" title="1">return &amp;header, nil</span>
}

// NewFrame creates a new frame with the specified parameters
func NewFrame(frameType FrameType, sessionID, sequence uint32, timestamp uint64, data []byte) *Frame <span class="cov8" title="1">{
        return &amp;Frame{
                Type:      frameType,
                SessionID: sessionID,
                Sequence:  sequence,
                Timestamp: timestamp,
                Data:      data,
        }
}</span>

// IsValid checks if the frame is structurally valid
func (f *Frame) IsValid() bool <span class="cov8" title="1">{
        return len(f.Data) &lt;= MaxDataSize
}</span>

// Size returns the total serialized size of the frame
func (f *Frame) Size() int <span class="cov8" title="1">{
        return HeaderSize + len(f.Data)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package transport

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "io"
        "log"
        "math/rand"
        "net/http"
        "net/url"
        "sync"
        "time"
)

// HTTPStreamingClient handles HTTP/1.1 streaming communication with the hub
type HTTPStreamingClient struct {
        hubURL         string
        puckID         string
        sessionID      string
        sequence       uint32
        mutex          sync.Mutex
        connectTimeout time.Duration

        // HTTP client for requests
        client      *http.Client
        isConnected bool

        // Context for connection lifecycle
        ctx    context.Context
        cancel context.CancelFunc

        // Streaming connection
        response *http.Response
        reader   *bufio.Reader
        writer   io.WriteCloser
}

// NewHTTPStreamingClient creates a new HTTP streaming client
func NewHTTPStreamingClient(hubURL, puckID string) *HTTPStreamingClient <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        // Create HTTP transport with aggressive cleanup settings
        transport := &amp;http.Transport{
                MaxIdleConns:        1,
                MaxIdleConnsPerHost: 1,
                IdleConnTimeout:     1 * time.Second,
                DisableKeepAlives:   true, // Disable connection pooling for cleaner shutdown
                ForceAttemptHTTP2:   false,
        }

        return &amp;HTTPStreamingClient{
                hubURL:         hubURL,
                puckID:         puckID,
                sessionID:      generateSessionID(),
                sequence:       0,
                connectTimeout: 10 * time.Second, // Default timeout
                client:         &amp;http.Client{
                        Timeout:   0, // No timeout for persistent streaming
                        Transport: transport,
                },
                ctx:    ctx,
                cancel: cancel,
        }
}</span>

// SetConnectTimeout sets the connection timeout for testing
func (c *HTTPStreamingClient) SetConnectTimeout(timeout time.Duration) <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        c.connectTimeout = timeout
}</span>

// Connect establishes HTTP streaming connection to the hub
func (c *HTTPStreamingClient) Connect() error <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if c.isConnected </span><span class="cov0" title="0">{
                return fmt.Errorf("already connected")
        }</span>

        <span class="cov8" title="1">log.Printf("üîó Connecting to hub at %s", c.hubURL)

        // Parse the hub URL and construct streaming endpoint
        u, err := url.Parse(c.hubURL)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid hub URL: %w", err)
        }</span>

        // Construct the streaming endpoint URL
        <span class="cov8" title="1">streamURL := fmt.Sprintf("http://%s/stream/puck?puck_id=%s", u.Host, c.puckID)

        // Create HTTP request for streaming with empty body initially
        // We'll handle bidirectional communication after connection establishment
        req, err := http.NewRequestWithContext(c.ctx, "POST", streamURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set headers for bidirectional streaming
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("Transfer-Encoding", "chunked")
        req.Header.Set("Connection", "keep-alive")
        req.Header.Set("X-Puck-ID", c.puckID)
        req.Header.Set("X-Session-ID", c.sessionID)

        // Start the request in a goroutine
        responseChan := make(chan *http.Response, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                log.Printf("üöÄ Starting HTTP request...")
                resp, err := c.client.Do(req)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("‚ùå HTTP request failed: %v", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">log.Printf("‚úÖ HTTP request succeeded with status: %d", resp.StatusCode)
                responseChan &lt;- resp</span>
        }()

        // Wait for the connection to establish with proper timeout
        <span class="cov8" title="1">select </span>{
        case resp := &lt;-responseChan:<span class="cov8" title="1">
                if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                        if err := resp.Body.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ö†Ô∏è Failed to close response body: %v", err)
                        }</span>
                        <span class="cov8" title="1">return fmt.Errorf("unexpected status code: %d", resp.StatusCode)</span>
                }
                <span class="cov8" title="1">c.response = resp
                c.reader = bufio.NewReader(resp.Body)
                c.writer = nil</span> // We'll set this up later for streaming

                // Connection established successfully
                // Note: Handshake frame sending moved to after isConnected is set

        case err := &lt;-errorChan:<span class="cov8" title="1">
                return fmt.Errorf("failed to connect to hub: %w", err)</span>

        case &lt;-time.After(c.connectTimeout):<span class="cov8" title="1">
                return fmt.Errorf("connection timeout")</span>
        }

        <span class="cov8" title="1">c.isConnected = true
        log.Printf("‚úÖ Connected to hub successfully (session: %s)", c.sessionID)
        return nil</span>
}

// SendHandshake sends a handshake frame to establish the session with the hub
func (c *HTTPStreamingClient) SendHandshake() error <span class="cov8" title="1">{
        if !c.isConnected </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected to hub")
        }</span>

        // Create handshake data with session information
        <span class="cov8" title="1">handshakeData := fmt.Sprintf("session:%s;puck:%s", c.sessionID, c.puckID)

        log.Printf("ü§ù Sending handshake frame (session: %s)", c.sessionID)
        return c.SendFrame(FrameTypeHandshake, []byte(handshakeData))</span>
}

// SendFrame sends a frame to the hub via separate HTTP request
func (c *HTTPStreamingClient) SendFrame(frameType FrameType, data []byte) error <span class="cov8" title="1">{
        if !c.isConnected </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected to hub")
        }</span>

        <span class="cov8" title="1">c.mutex.Lock()
        c.sequence++
        seq := c.sequence
        c.mutex.Unlock()

        frame := NewFrame(
                frameType,
                c.getSessionIDHash(),
                seq,
                uint64(time.Now().UnixMicro()), //nolint:gosec // Safe conversion from int64 to uint64
                data,
        )

        frameData, err := frame.Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to serialize frame: %w", err)
        }</span>

        // For HTTP/1.1, send frames via separate POST requests
        // This is more compatible than trying to use bidirectional streaming
        <span class="cov8" title="1">sendURL := fmt.Sprintf("%s/send/puck?puck_id=%s", c.hubURL, c.puckID)

        req, err := http.NewRequestWithContext(c.ctx, "POST", sendURL, bytes.NewReader(frameData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create send request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/octet-stream")
        req.Header.Set("X-Puck-ID", c.puckID)
        req.Header.Set("X-Session-ID", c.sessionID)

        resp, err := c.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to send frame: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if closeErr := resp.Body.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to close send response body: %v", closeErr)
                }</span>
        }()

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("send frame failed with status: %d", resp.StatusCode)
        }</span>

        // Only log non-audio frames to reduce test noise
        <span class="cov8" title="1">if frame.Type != FrameTypeAudioData </span><span class="cov8" title="1">{
                log.Printf("üì§ Sent frame type %d (%d bytes)", frame.Type, len(frameData))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// StartStreaming begins the streaming process with frame handler
func (c *HTTPStreamingClient) StartStreaming(frameHandler func(*Frame) error) error <span class="cov8" title="1">{
        if !c.isConnected </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected to hub")
        }</span>

        // Start incoming frame reader
        <span class="cov8" title="1">go c.handleIncomingFrames(frameHandler)

        log.Println("üéôÔ∏è HTTP streaming started")
        return nil</span>
}

// handleIncomingFrames processes frames received from the hub
func (c *HTTPStreamingClient) handleIncomingFrames(frameHandler func(*Frame) error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ùå Incoming frame handler panic: %v", r)
                }</span>
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov8" title="1">
                        // Read frame header first
                        headerData := make([]byte, HeaderSize)
                        if _, err := io.ReadFull(c.reader, headerData); err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov8" title="1">{
                                        log.Println("üéôÔ∏è Stream ended")
                                        return
                                }</span>
                                <span class="cov8" title="1">log.Printf("‚ùå Failed to read frame header: %v", err)
                                return</span>
                        }

                        // Parse header
                        <span class="cov8" title="1">header, err := parseFrameHeader(headerData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ùå Invalid frame header: %v", err)
                                continue</span>
                        }

                        // Read frame data if present
                        <span class="cov8" title="1">var frameData []byte
                        if header.Length &gt; 0 </span><span class="cov8" title="1">{
                                frameData = make([]byte, header.Length)
                                if _, err := io.ReadFull(c.reader, frameData); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("‚ùå Failed to read frame data: %v", err)
                                        continue</span>
                                }
                        }

                        // Reconstruct full frame data for deserialization
                        <span class="cov8" title="1">fullFrameData := append(headerData, frameData...)
                        frame, err := DeserializeFrame(fullFrameData)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ùå Failed to deserialize frame: %v", err)
                                continue</span>
                        }

                        <span class="cov8" title="1">log.Printf("üì• Received frame type %d (%d bytes)", frame.Type, len(frame.Data))

                        // Handle the frame
                        if frameHandler != nil </span><span class="cov8" title="1">{
                                if err := frameHandler(frame); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("‚ùå Frame handler error: %v", err)
                                }</span>
                        }
                }
        }
}

// SendAudioData sends audio data as a frame
func (c *HTTPStreamingClient) SendAudioData(audioData []byte) error <span class="cov8" title="1">{
        return c.SendFrame(FrameTypeAudioData, audioData)
}</span>

// SendWakeWord sends a wake word detection frame
func (c *HTTPStreamingClient) SendWakeWord(audioData []byte) error <span class="cov8" title="1">{
        return c.SendFrame(FrameTypeWakeWord, audioData)
}</span>

// SendHeartbeat sends a heartbeat frame to keep the connection alive
func (c *HTTPStreamingClient) SendHeartbeat() error <span class="cov8" title="1">{
        return c.SendFrame(FrameTypeHeartbeat, nil)
}</span>

// Disconnect closes the connection to the hub
func (c *HTTPStreamingClient) Disconnect() <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()

        if !c.isConnected </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">log.Println("üîó Disconnecting from hub...")

        // Cancel context to stop goroutines
        c.cancel()

        // Close writer
        if c.writer != nil </span><span class="cov0" title="0">{
                if err := c.writer.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to close writer: %v", err)
                }</span>
        }

        // Close response body
        <span class="cov8" title="1">if c.response != nil </span><span class="cov8" title="1">{
                if err := c.response.Body.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("‚ö†Ô∏è Failed to close response body: %v", err)
                }</span>
        }

        // Force close idle connections in the HTTP transport
        <span class="cov8" title="1">if transport, ok := c.client.Transport.(*http.Transport); ok </span><span class="cov8" title="1">{
                transport.CloseIdleConnections()
        }</span>

        <span class="cov8" title="1">c.isConnected = false
        log.Println("üëã Disconnected from hub")</span>
}

// IsConnected returns whether the client is currently connected
func (c *HTTPStreamingClient) IsConnected() bool <span class="cov8" title="1">{
        c.mutex.Lock()
        defer c.mutex.Unlock()
        return c.isConnected
}</span>

// GetSessionID returns the current session ID
func (c *HTTPStreamingClient) GetSessionID() string <span class="cov8" title="1">{
        return c.sessionID
}</span>

// getSessionIDHash returns a hash of the session ID for frame headers
func (c *HTTPStreamingClient) getSessionIDHash() uint32 <span class="cov8" title="1">{
        hash := uint32(0)
        for _, b := range []byte(c.sessionID) </span><span class="cov8" title="1">{
                hash = hash*31 + uint32(b)
        }</span>
        <span class="cov8" title="1">return hash</span>
}

// generateSessionID creates a unique session identifier
func generateSessionID() string <span class="cov8" title="1">{
        // Session ID generation with timestamp and random component for uniqueness
        now := time.Now()
        random := rand.Int63n(1000000) // Random number 0-999999
        return fmt.Sprintf("puck-%d-%d-%d", now.Unix(), now.Nanosecond(), random)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * This file is part of Loqa (https://github.com/loqalabs/loqa).
 * Copyright (C) 2025 Loqa Labs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;https://www.gnu.org/licenses/&gt;.
 */

package transport

import (
        "fmt"
        "log"
        "time"

        "github.com/loqalabs/loqa-puck-go/internal/audio"
)

// PuckClient provides a high-level interface for streaming audio to the hub
// This replaces the previous gRPC-based client with HTTP/1.1 streaming
type PuckClient struct {
        streamingClient *HTTPStreamingClient
        hubAddress      string
        puckID          string
        isConnected     bool

        // Response handling would go here if needed in future
}

// NewPuckClient creates a new puck client for HTTP streaming
func NewPuckClient(hubAddress, puckID string) *PuckClient <span class="cov8" title="1">{
        return &amp;PuckClient{
                streamingClient: NewHTTPStreamingClient(hubAddress, puckID),
                hubAddress:      hubAddress,
                puckID:          puckID,
                isConnected:     false,
        }
}</span>

// Connect establishes connection to the hub
func (pc *PuckClient) Connect() error <span class="cov8" title="1">{
        log.Printf("üîó Puck: Connecting to hub at %s", pc.hubAddress)

        if err := pc.streamingClient.Connect(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to connect to hub: %w", err)
        }</span>

        <span class="cov8" title="1">pc.isConnected = true
        log.Printf("‚úÖ Puck: Connected to hub successfully")
        return nil</span>
}

// SendHandshake sends a handshake frame to establish the session with the hub
func (pc *PuckClient) SendHandshake() error <span class="cov8" title="1">{
        if !pc.isConnected </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected to hub")
        }</span>

        <span class="cov8" title="1">log.Printf("ü§ù Puck: Sending handshake frame")
        return pc.streamingClient.SendHandshake()</span>
}

// StreamAudio starts streaming audio chunks to the hub
// This maintains the same interface as the previous gRPC client
func (pc *PuckClient) StreamAudio(audioChan &lt;-chan audio.AudioChunk, responseChan chan&lt;- interface{}) error <span class="cov8" title="1">{
        if !pc.isConnected </span><span class="cov8" title="1">{
                return fmt.Errorf("not connected to hub")
        }</span>

        // Start the HTTP streaming
        <span class="cov8" title="1">frameHandler := func(frame *Frame) error </span><span class="cov8" title="1">{
                return pc.handleIncomingFrame(frame, responseChan)
        }</span>

        <span class="cov8" title="1">if err := pc.streamingClient.StartStreaming(frameHandler); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start streaming: %w", err)
        }</span>

        <span class="cov8" title="1">log.Println("üéôÔ∏è Puck: Audio streaming started")

        // Start goroutine to handle outgoing audio chunks
        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Printf("‚ùå Audio streaming panic: %v", r)
                        }</span>
                }()

                <span class="cov8" title="1">chunkCount := 0
                for </span><span class="cov8" title="1">{ //nolint:staticcheck // Channel-based communication pattern
                        select </span>{
                        case audioChunk, ok := &lt;-audioChan:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        log.Println("üéôÔ∏è Puck: Audio channel closed")
                                        return
                                }</span>

                                // Convert audio chunk to binary data
                                <span class="cov8" title="1">audioData := pc.convertAudioChunkToBytes(audioChunk)

                                // Determine frame type based on audio chunk properties
                                var frameType FrameType
                                if audioChunk.IsWakeWord </span><span class="cov8" title="1">{
                                        frameType = FrameTypeWakeWord
                                }</span> else<span class="cov8" title="1"> {
                                        frameType = FrameTypeAudioData
                                }</span>

                                // Send frame to hub
                                <span class="cov8" title="1">if err := pc.streamingClient.SendFrame(frameType, audioData); err != nil </span><span class="cov8" title="1">{
                                        log.Printf("‚ùå Failed to send audio frame: %v", err)
                                        continue</span>
                                }

                                <span class="cov8" title="1">chunkCount++
                                // Only log occasionally to reduce test noise
                                if chunkCount%10 == 0 </span><span class="cov8" title="1">{
                                        log.Printf("üì§ Puck: Sent audio chunk (%d samples)", len(audioChunk.Data))
                                }</span>
                        }
                }
        }()

        // Start heartbeat goroutine
        <span class="cov8" title="1">go pc.startHeartbeat()

        return nil</span>
}

// handleIncomingFrame processes frames received from the hub
func (pc *PuckClient) handleIncomingFrame(frame *Frame, responseChan chan&lt;- interface{}) error <span class="cov8" title="1">{
        switch frame.Type </span>{
        case FrameTypeResponse:<span class="cov8" title="1">
                log.Printf("üì• Puck: Received response frame (%d bytes)", len(frame.Data))
                // Send the raw frame data directly to maintain compatibility
                if responseChan != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case responseChan &lt;- frame.Data:<span class="cov8" title="1"></span>
                                // Successfully sent response data
                        default:<span class="cov0" title="0">
                                log.Println("‚ö†Ô∏è Response channel full, dropping response")</span>
                        }
                }

        case FrameTypeStatus:<span class="cov8" title="1">
                log.Printf("üì• Puck: Received status frame (%d bytes)", len(frame.Data))
                // Send status data to response channel for processing
                if responseChan != nil </span><span class="cov8" title="1">{
                        select </span>{
                        case responseChan &lt;- frame.Data:<span class="cov8" title="1"></span>
                                // Successfully sent status data
                        default:<span class="cov0" title="0">
                                log.Println("‚ö†Ô∏è Response channel full, dropping status")</span>
                        }
                }

        case FrameTypeHeartbeat:<span class="cov8" title="1">
                log.Printf("üì• Puck: Received heartbeat from hub")</span>
                // Hub is alive, no action needed

        case FrameTypeError:<span class="cov8" title="1">
                log.Printf("‚ùå Puck: Received error frame: %s", string(frame.Data))</span>
                // Log error but don't return error to avoid breaking the streaming loop

        default:<span class="cov0" title="0">
                log.Printf("‚ö†Ô∏è Puck: Received unknown frame type: %d", frame.Type)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// convertAudioChunkToBytes converts an AudioChunk to binary data
func (pc *PuckClient) convertAudioChunkToBytes(chunk audio.AudioChunk) []byte <span class="cov8" title="1">{
        // Convert float32 samples to 16-bit PCM bytes
        data := make([]byte, len(chunk.Data)*2)
        for i, sample := range chunk.Data </span><span class="cov8" title="1">{
                // Convert from float32 [-1,1] to int16 [-32768,32767]
                // Scale by 32768 but clamp to valid int16 range
                scaled := sample * 32768
                var val int16
                if scaled &gt; 32767 </span><span class="cov8" title="1">{
                        val = 32767
                }</span> else<span class="cov8" title="1"> if scaled &lt;= -32768 </span><span class="cov8" title="1">{
                        val = -32767  // Use -32767 instead of -32768 for symmetry
                }</span> else<span class="cov8" title="1"> {
                        val = int16(scaled)
                }</span>
                <span class="cov8" title="1">data[i*2] = byte(val)
                data[i*2+1] = byte(val &gt;&gt; 8)</span>
        }
        <span class="cov8" title="1">return data</span>
}

// startHeartbeat sends periodic heartbeats to keep the connection alive
func (pc *PuckClient) startHeartbeat() <span class="cov8" title="1">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{ //nolint:staticcheck // Ticker-based heartbeat pattern
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if pc.isConnected </span><span class="cov0" title="0">{
                                if err := pc.streamingClient.SendHeartbeat(); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("‚ö†Ô∏è Failed to send heartbeat: %v", err)
                                }</span>
                        }
                }
        }
}

// Disconnect closes the connection to the hub
func (pc *PuckClient) Disconnect() <span class="cov8" title="1">{
        if pc.streamingClient != nil </span><span class="cov8" title="1">{
                pc.streamingClient.Disconnect()
        }</span>
        <span class="cov8" title="1">pc.isConnected = false
        log.Println("üîó Puck: Disconnected from hub")</span>
}

// IsConnected returns whether the client is currently connected
func (pc *PuckClient) IsConnected() bool <span class="cov8" title="1">{
        return pc.isConnected &amp;&amp; pc.streamingClient.IsConnected()
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
